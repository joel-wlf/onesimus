"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStack = exports.getOrCreateStack = exports.doSetup = void 0;
const clc = require("colorette");
const utils = require("../../../utils");
const logger_1 = require("../../../logger");
const prompt_1 = require("../../../prompt");
const constants_1 = require("./constants");
const repo = require("./repo");
const poller = require("../../../operation-poller");
const api_1 = require("../../../api");
const gcp = require("../../../gcp/frameworks");
const frameworks_1 = require("../../../gcp/frameworks");
const error_1 = require("../../../error");
const frameworksPollerOptions = {
    apiOrigin: api_1.frameworksOrigin,
    apiVersion: frameworks_1.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
async function doSetup(setup) {
    var _a, _b;
    const projectId = (_b = (_a = setup === null || setup === void 0 ? void 0 : setup.rcfile) === null || _a === void 0 ? void 0 : _a.projects) === null || _b === void 0 ? void 0 : _b.default;
    setup.frameworks = {};
    utils.logBullet("First we need a few details to create your service.");
    await (0, prompt_1.promptOnce)({
        name: "serviceName",
        type: "input",
        default: "acme-inc-web",
        message: "Create a name for your service [1-30 characters]",
    }, setup.frameworks);
    await (0, prompt_1.promptOnce)({
        name: "region",
        type: "list",
        default: constants_1.DEFAULT_REGION,
        message: "Please select a region " +
            `(${clc.yellow("info")}: Your region determines where your backend is located):\n`,
        choices: constants_1.ALLOWED_REGIONS,
    }, setup.frameworks);
    utils.logSuccess(`Region set to ${setup.frameworks.region}.`);
    logger_1.logger.info(clc.bold(`\n${clc.white("===")} Deploy Setup`));
    await (0, prompt_1.promptOnce)({
        name: "deployMethod",
        type: "list",
        default: constants_1.DEFAULT_DEPLOY_METHOD,
        message: "How do you want to deploy",
        choices: constants_1.ALLOWED_DEPLOY_METHODS,
    }, setup.frameworks);
    await getOrCreateStack(projectId, setup);
}
exports.doSetup = doSetup;
function toStack(cloudBuildConnRepo, stackId) {
    return {
        name: stackId,
        labels: {},
    };
}
async function getOrCreateStack(projectId, setup) {
    const location = setup.frameworks.region;
    const deployMethod = setup.frameworks.deployMethod;
    try {
        return await getExistingStack(projectId, setup, location);
    }
    catch (err) {
        if (err.status === 404) {
            logger_1.logger.info("Creating new stack.");
            if (deployMethod === "github") {
                const cloudBuildConnRepo = await repo.linkGitHubRepository(projectId, location, setup.frameworks.serviceName);
                const stackDetails = toStack(cloudBuildConnRepo, setup.frameworks.serviceName);
                return await createStack(projectId, location, stackDetails);
            }
        }
        else {
            throw new error_1.FirebaseError(`Failed to get or create a stack using the given initialization details: ${err}`);
        }
    }
    return undefined;
}
exports.getOrCreateStack = getOrCreateStack;
async function getExistingStack(projectId, setup, location) {
    let stack = await gcp.getStack(projectId, location, setup.frameworks.serviceName);
    while (stack) {
        setup.frameworks.serviceName = undefined;
        await (0, prompt_1.promptOnce)({
            name: "existingStack",
            type: "confirm",
            default: true,
            message: "A stack already exists for the given serviceName, do you want to use existing stack? (yes/no)",
        }, setup.frameworks);
        if (setup.frameworks.existingStack) {
            logger_1.logger.info("Using the existing stack.");
            return stack;
        }
        await (0, prompt_1.promptOnce)({
            name: "serviceName",
            type: "input",
            default: "acme-inc-web",
            message: "Please enter a new service name [1-30 characters]",
        }, setup.frameworks);
        stack = await gcp.getStack(projectId, location, setup.frameworks.serviceName);
        setup.frameworks.existingStack = undefined;
    }
    return stack;
}
async function createStack(projectId, location, stackInput) {
    const op = await gcp.createStack(projectId, location, stackInput);
    const stack = await poller.pollOperation(Object.assign(Object.assign({}, frameworksPollerOptions), { pollerName: `create-${projectId}-${location}-${stackInput.name}`, operationResourceName: op.name }));
    return stack;
}
exports.createStack = createStack;
